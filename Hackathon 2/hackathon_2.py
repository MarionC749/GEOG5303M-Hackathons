# -*- coding: utf-8 -*-
"""Hackathon 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13WBuggms1mTwzcoCsizc9d0zkgh4wPph

# Hackathon 2

## Import packages
"""

pip install folium matplotlib mapclassify pysal geopandas

#Import packages
import pandas as pd
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt
import geopandas as gpd
from pysal.viz import mapclassify
import numpy as np
import mapclassify

"""## Data Loading and Exploration"""

#Load Leeds shape file
LeedsOA = gpd.read_file('LeedsOA.shp')
LeedsOA.info()

LeedsOA.plot()

#Load EPC Recommendations data
EPCrecom = pd.read_csv('EPCRecommendations.csv')
EPCrecom.head()

#Load EPC Certificates data
EPCcertif = pd.read_csv('EPCertificates.csv')
EPCcertif.head()

#Load Leeds heat stress shape file
LeedsHeat = gpd.read_file('leeds_heat_stress.shp')
LeedsHeat.info()

#Load previously tidied geometry data for EPCcertif df (see other notebook for data wrangling)
EPCpointsgeom = gpd.read_file('epcgdf.shp')
EPCpointsgeom.info()

LeedsHeat.head()

EPCcertif.info()

"""##Getting Geometries of properties

Adding geometries has been done offline, because Colab is not able to process the original Ordnance Survey UPRN file of 41 million rows. This EPCpointsgeom data will now be merged with the EPCcertif dataframe to create a new geodataframe.
"""

EPCpointsgeom.head()

#dropping UPRN row from EPCpointsgeom so it's not duplicated in join
EPCpointsgeom = EPCpointsgeom.drop(columns='UPRN')

#merging geometry shp to main dataframe
EPCcertif = EPCcertif.merge(EPCpointsgeom, on='LMK_KEY', how='left')

EPCcertif.info()

#converting dataframe into geodataframe
EPCcertif = gpd.GeoDataFrame(
    EPCcertif, geometry='geometry', crs='27700')

fig, ax = plt.subplots(1,1, figsize=(10,10))
LeedsOA.plot(ax = ax, facecolor = 'lightgray', edgecolor = 'lightgray', linewidth = 0.2)
EPCcertif.plot(ax = ax, color = '#008080', linewidth = 0.5, alpha = 0.2)
ax.set_axis_off()
plt.show()

"""## Mapping heat stress"""

LeedsHeat['heat_stres'].unique()

from matplotlib.lines import Line2D  # for legend handle

#Assign colors to each heat stress type
heat_stress_colors = {
    'Very Low': 'limegreen',
    'Low': 'yellowgreen',
    'Medium': 'gold',
    'High': 'orange',
    'Very High': 'red'}

#Plot Leeds map with colors based in the heat stress type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsHeat.plot(ax=ax, column='heat_stres',
               color=LeedsHeat['heat_stres'].map(heat_stress_colors),
               legend=True)
ax.set_title('Leeds Heat Stress', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Heat Stress category', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""## Data Cleaning

Keep only the columns we will be using for the matrix.
"""

#Create new dataset keeping only the variables used in our matrix
Matrix = EPCcertif[['PROPERTY_TYPE', 'BUILT_FORM', 'TOTAL_FLOOR_AREA', 'FLAT_TOP_STOREY',
                   'MULTI_GLAZE_PROPORTION', 'GLAZED_TYPE', 'NUMBER_OPEN_FIREPLACES',
                   'FLOOR_DESCRIPTION', 'WALLS_DESCRIPTION', 'ROOF_DESCRIPTION',
                    'CONSTRUCTION_AGE_BAND', 'UPRN', 'geometry', 'heat_stres', 'heat_str_1', 'LMK_KEY']]
#Add index column at the beginning
Matrix.insert(0, 'Index', range(1, len(Matrix) + 1))
#Check
Matrix.head()

#checking Matrix is still a geodataframe
Matrix.info()

"""##Scoring **roof** heat stress"""

#Need to delete lines with no information of roof insulation (no U values or no insulation thickness)

#Get index of rows where 'ROOF_DESCRIPTION' needs to be deleted
rows_drop = Matrix[Matrix['ROOF_DESCRIPTION'].isin([
'Flat',
'Flat,',
'Pitched',
'Pitched,',
'Pitched, *** INVALID INPUT Code : 57 *** loft insulation',
'Pitched, Unknown loft insulation',
'Roof room(s),'
'Roof room(s), thatched',
'SAP05:Roof',
'Thatched'])].index

#Drop the rows
Matrix = Matrix.drop(rows_drop)
#Check dataset
Matrix['ROOF_DESCRIPTION'].unique()

"""We create a new column to score the roof insulation. To do this we categorize the roof descriptions into the following categories and assign them a score:
* Very good = 20%
* Good = 40%
* Medium = 60%
* Poor = 80%
* Very Poor = 100%

The higher the score the more heat stress.
"""

#Create function to assign a roof heat stress score based on roof description

def assign_roof_score(roof_description):

  #assign 0.2 (Very good) score to all these roof descriptions
    if roof_description in [
'Average thermal transmittance = 0.01 W/m?K',
'Average thermal transmittance = 0.04 W/m?K',
'Average thermal transmittance = 0.06 W/m?K',
'Average thermal transmittance = 0.10 W/m?K',
'Average thermal transmittance 0 W/m?K',
'Average thermal transmittance 0.00 W/m&#0178;K',
'Average thermal transmittance 0.00 W/m?K',
'Average thermal transmittance 0.01 W/m?K',
'Average thermal transmittance 0.02 W/m?K',
'Average thermal transmittance 0.04 W/m?K',
'Average thermal transmittance 0.05 W/m?K',
'Average thermal transmittance 0.05 W/m-Â¦K',
'Average thermal transmittance 0.06 W/m-Â¦K',
'Average thermal transmittance 0.07 W/m-Â¦K',
'Average thermal transmittance 0.08 W/m?K',
'Average thermal transmittance 0.08 W/m-Â¦K',
'Average thermal transmittance 0.09 W/m&#0178;K',
'Average thermal transmittance 0.09 W/m??K|Trawsyriannedd thermol cyfartalog 0.09 W/m??K',
'Average thermal transmittance 0.09 W/m?K',
'Average thermal transmittance 0.09 W/m-Â¦K',
'Average thermal transmittance 0.1 W/m?K',
'Average thermal transmittance 0.1 W/m-Â¦K',
'Average thermal transmittance 0.10 W/m??K',
'Average thermal transmittance 0.10 W/m?K',
'Average thermal transmittance 0.10 W/m+Ã©-Â¦K',
'Average thermal transmittance 0.10 W/mA?K',
'Average thermal transmittance 0.10 W/m-Â¦K',
'Pitched, 350 mm loft insulation',
'Pitched, 400 mm loft insulation',
'Pitched, 400+  mm loft insulation',
'Pitched, 400+ mm loft insulation'
]:
        return 0.2

#assign 0.4 (Good) score to all these roof descriptions
    elif roof_description in [
'Average thermal transmittance = 0.12 W/m?K',
'Average thermal transmittance = 0.13 W/m?K',
'Average thermal transmittance = 0.14 W/m?K',
'Average thermal transmittance = 0.15 W/m?K',
'Average thermal transmittance = 0.16 W/m?K',
'Average thermal transmittance 0.11 W/m??K',
'Average thermal transmittance 0.11 W/m??K|Trawsyriannedd thermol cyfartalog 0.11 W/m??K',
'Average thermal transmittance 0.11 W/m?K',
'Average thermal transmittance 0.11 W/m+Ã©-Â¦K',
'Average thermal transmittance 0.11 W/m-Â¦K',
'Average thermal transmittance 0.12 W/m&#0178;K',
'Average thermal transmittance 0.12 W/m??K',
'Average thermal transmittance 0.12 W/m??K|Trawsyriannedd thermol cyfartalog 0.12 W/m??K',
'Average thermal transmittance 0.12 W/m?K',
'Average thermal transmittance 0.12 W/m+Ã©-Â¦K',
'Average thermal transmittance 0.12 W/m2K',
'Average thermal transmittance 0.12 W/m-Â¦K',
'Average thermal transmittance 0.13 W/m&#0178;K',
'Average thermal transmittance 0.13 W/m??K',
'Average thermal transmittance 0.13 W/m??K|Trawsyriannedd thermol cyfartalog 0.13 W/m??K',
'Average thermal transmittance 0.13 W/m?K',
'Average thermal transmittance 0.13 W/m2K',
'Average thermal transmittance 0.13 W/m-Â¦K',
'Average thermal transmittance 0.130 W/m-Â¦K',
'Average thermal transmittance 0.14 W/m&#0178;K',
'Average thermal transmittance 0.14 W/m??K',
'Average thermal transmittance 0.14 W/m??K|Trawsyriannedd thermol cyfartalog 0.14 W/m??K',
'Average thermal transmittance 0.14 W/m?K',
'Average thermal transmittance 0.14 W/m?K|Trawsyriannedd thermol cyfartalog 0.14 W/m?K',
'Average thermal transmittance 0.14 W/m+Ã©-Â¦K',
'Average thermal transmittance 0.14 W/m2K',
'Average thermal transmittance 0.14 W/mA?K',
'Average thermal transmittance 0.14 W/m-Â¦K',
'Average thermal transmittance 0.146 W/m-Â¦K',
'Average thermal transmittance 0.15 W/m&#0178;K',
'Average thermal transmittance 0.15 W/m??K',
'Average thermal transmittance 0.15 W/m??K|Trawsyriannedd thermol cyfartalog 0.15 W/m??K',
'Average thermal transmittance 0.15 W/m?K',
'Average thermal transmittance 0.15 W/m+Ã©-Â¦K',
'Average thermal transmittance 0.15 W/m2K',
'Average thermal transmittance 0.15 W/mA?K',
'Average thermal transmittance 0.15 W/m-Â¦K',
'Average thermal transmittance 0.152 W/m-Â¦K',
'Average thermal transmittance 0.159 W/m-Â¦K',
'Average thermal transmittance 0.16 W/m&#0178;K',
'Average thermal transmittance 0.16 W/m??K',
'Average thermal transmittance 0.16 W/m??K|Trawsyriannedd thermol cyfartalog 0.16 W/m??K',
'Average thermal transmittance 0.16 W/m?K',
'Average thermal transmittance 0.16 W/m+Ã©-Â¦K',
'Average thermal transmittance 0.16 W/m2K',
'Average thermal transmittance 0.16 W/mA?K',
'Average thermal transmittance 0.16 W/m-Â¦K',
'Flat, insulated',
'Flat, insulated (assumed)',
'Pitched,  loft insulation',
'Pitched,  mm loft insulation',
'Pitched, >=300 mm loft insulation',
'Pitched, 250 mm loft insulation',
'Pitched, 250mm loft insulation',
'Pitched, 270 mm loft insulation',
'Pitched, 300 mm loft insulation',
'Pitched, 300+  mm loft insulation',
'Pitched, 300+ mm loft insulation',
'Pitched, 300+mm loft insulation',
'Pitched, 300mm loft insulation',
'Pitched, insulated',
'Pitched, insulated (assumed)',
'Pitched, insulated at rafters',
'Pitched, loft insulation',
'Pitched, mm loft insulation',
'Roof room(s), ceiling insulated',
'Roof room(s), insulated',
'Roof room(s), insulated (assumed)',
'Thatched, with additional insulation'
]:
        return 0.4

#assign 0.6 (Medium) score to all these roof descriptions
    elif roof_description in [
'(another dwelling above)',
'(other premises above)',
'(other premises above)|(eiddo arall uwchben)',
'Ar oleddf, 200 mm o inswleiddio yn y llofft',
'Average thermal transmittance = 0.17 W/m?K',
'Average thermal transmittance = 0.18 W/m?K',
'Average thermal transmittance = 0.19 W/m?K',
'Average thermal transmittance = 0.20 W/m?K',
'Average thermal transmittance 0.17 W/m&#0178;K',
'Average thermal transmittance 0.17 W/m??K',
'Average thermal transmittance 0.17 W/m??K|Trawsyriannedd thermol cyfartalog 0.17 W/m??K',
'Average thermal transmittance 0.17 W/m?K',
'Average thermal transmittance 0.17 W/m+Ã©-Â¦K',
'Average thermal transmittance 0.17 W/m2K',
'Average thermal transmittance 0.17 W/mA?K',
'Average thermal transmittance 0.17 W/m-Â¦K',
'Average thermal transmittance 0.18 W/m&#0178;K',
'Average thermal transmittance 0.18 W/m??K',
'Average thermal transmittance 0.18 W/m??K|Trawsyriannedd thermol cyfartalog 0.18 W/m??K',
'Average thermal transmittance 0.18 W/m?K',
'Average thermal transmittance 0.18 W/m+Ã©-Â¦K',
'Average thermal transmittance 0.18 W/m2K',
'Average thermal transmittance 0.18 W/m-Â¦K',
'Average thermal transmittance 0.19 W/m??K',
'Average thermal transmittance 0.19 W/m?K',
'Average thermal transmittance 0.19 W/m+Ã©-Â¦K',
'Average thermal transmittance 0.19 W/m2K',
'Average thermal transmittance 0.19 W/m-Â¦K',
'Average thermal transmittance 0.2 W/m?K',
'Average thermal transmittance 0.2 W/m-Â¦K',
'Average thermal transmittance 0.20 W/m&#0178;K',
'Average thermal transmittance 0.20 W/m??K|Trawsyriannedd thermol cyfartalog 0.20 W/m??K',
'Average thermal transmittance 0.20 W/m?K',
'Average thermal transmittance 0.20 W/m2K',
'Average thermal transmittance 0.20 W/m-Â¦K',
'Flat, limited insulation',
'Flat, limited insulation (assumed)',
'Other premises above',
'Pitched, 200 mm loft insulation',
'Pitched, 200mm loft insulation',
'Pitched, limited insulation',
'Pitched, limited insulation (assumed)',
'Roof room(s), limited insulation',
'Roof room(s), limited insulation (assumed)'
]:
        return 0.6

#assign 0.8 (Poor) score to all these these roof descriptions
    elif roof_description in [
'Average thermal transmittance = 0.21 W/m?K',
'Average thermal transmittance = 0.22 W/m?K',
'Average thermal transmittance = 0.23 W/m?K',
'Average thermal transmittance = 0.24 W/m?K',
'Average thermal transmittance = 0.25 W/m?K',
'Average thermal transmittance = 0.32 W/m?K',
'Average thermal transmittance 0.21 W/m&#0178;K',
'Average thermal transmittance 0.21 W/m??K',
'Average thermal transmittance 0.21 W/m?K',
'Average thermal transmittance 0.21 W/m-Â¦K',
'Average thermal transmittance 0.22 W/m&#0178;K',
'Average thermal transmittance 0.22 W/m??K|Trawsyriannedd thermol cyfartalog 0.22 W/m??K',
'Average thermal transmittance 0.22 W/m?K',
'Average thermal transmittance 0.22 W/m-Â¦K',
'Average thermal transmittance 0.23 W/m??K',
'Average thermal transmittance 0.23 W/m?K',
'Average thermal transmittance 0.23 W/m-Â¦K',
'Average thermal transmittance 0.24 W/m??K|Trawsyriannedd thermol cyfartalog 0.24 W/m??K',
'Average thermal transmittance 0.24 W/m?K',
'Average thermal transmittance 0.24 W/m-Â¦K',
'Average thermal transmittance 0.25 W/m??K',
'Average thermal transmittance 0.25 W/m?K',
'Average thermal transmittance 0.25 W/m-Â¦K',
'Average thermal transmittance 0.26 W/m?K',
'Average thermal transmittance 0.26 W/m-Â¦K',
'Average thermal transmittance 0.27 W/m?K',
'Average thermal transmittance 0.27 W/m-Â¦K',
'Average thermal transmittance 0.28 W/m?K',
'Average thermal transmittance 0.28 W/m-Â¦K',
'Average thermal transmittance 0.29 W/m?K',
'Average thermal transmittance 0.29 W/m-Â¦K',
'Average thermal transmittance 0.3 W/m-Â¦K',
'Average thermal transmittance 0.30 W/m?K',
'Average thermal transmittance 0.30 W/m-Â¦K',
'Average thermal transmittance 0.31 W/m?K',
'Average thermal transmittance 0.31 W/m-Â¦K',
'Average thermal transmittance 0.32 W/m?K',
'Average thermal transmittance 0.32 W/m-Â¦K',
'Average thermal transmittance 0.33 W/m?K',
'Average thermal transmittance 0.33 W/m-Â¦K',
'Average thermal transmittance 0.34 W/m?K',
'Average thermal transmittance 0.34 W/m-Â¦K',
'Average thermal transmittance 0.35 W/m?K',
'Average thermal transmittance 0.35 W/m-Â¦K',
'Average thermal transmittance 0.36 W/m-Â¦K',
'Average thermal transmittance 0.37 W/m-Â¦K',
'Average thermal transmittance 0.38 W/m-Â¦K',
'Average thermal transmittance 0.4 W/m-Â¦K',
'Average thermal transmittance 0.40 W/m-Â¦K',
'Average thermal transmittance 0.41 W/m-Â¦K',
'Average thermal transmittance 0.43 W/m-Â¦K',
'Average thermal transmittance 0.44 W/m-Â¦K',
'Average thermal transmittance 0.45 W/m-Â¦K',
'Pitched, 100 mm loft insulation',
'Pitched, 100mm loft insulation',
'Pitched, 150 mm loft insulation',
'Pitched, 150mm loft insulation'
]:
        return 0.8

#assign 1 (Very Poor) score to all these roof descriptions
    elif roof_description in [
'Ar oleddf, 25 mm o inswleiddio yn y llofft',
'Ar oleddf, 50 mm o inswleiddio yn y llofft',
'Ar oleddf, dim inswleiddio (rhagdybiaeth)',
'Average thermal transmittance 0.51 W/m-Â¦K',
'Average thermal transmittance 0.52 W/m-Â¦K',
'Average thermal transmittance 0.58 W/m-Â¦K',
'Average thermal transmittance 0.62 W/m-Â¦K',
'Average thermal transmittance 0.65 W/m-Â¦K',
'Average thermal transmittance 0.68 W/m-Â¦K',
'Average thermal transmittance 0.90 W/m-Â¦K',
'Average thermal transmittance 1.07 W/m-Â¦K',
'Average thermal transmittance 1.13 W/m-Â¦K',
'Average thermal transmittance 1.16 W/m-Â¦K',
'Average thermal transmittance 1.2 W/m-Â¦K',
'Average thermal transmittance 1.20 W/m-Â¦K',
'Average thermal transmittance 1.5 W/m-Â¦K',
'Average thermal transmittance 1.52 W/m-Â¦K',
'Average thermal transmittance 1.60 W/m-Â¦K',
'Average thermal transmittance 2.3 W/m-Â¦K',
'Average thermal transmittance 2.30 W/m?K',
'Average thermal transmittance 2.30 W/m-Â¦K',
'Average thermal transmittance 5.01 W/m-Â¦K',
'Flat, no insulation',
'Flat, no insulation (assumed)',
'Pitched, 0 mm loft insulation',
'Pitched, 0mm loft insulation',
'Pitched, 1 mm loft insulation',
'Pitched, 12 mm loft insulation',
'Pitched, 12mm loft insulation',
'Pitched, 25 mm loft insulation',
'Pitched, 25mm loft insulation',
'Pitched, 50 mm loft insulation',
'Pitched, 50mm loft insulation',
'Pitched, 75 mm loft insulation'
]:
        return 1

    else:
        return 1  #Default for unknown roof descriptions

#Apply function to create new column with roof heat stress score based on roof description
Matrix['Roof_Score'] = Matrix['ROOF_DESCRIPTION'].apply(assign_roof_score)

#Check
Matrix.head()

from matplotlib.lines import Line2D  #for legend handle

#Plot Roof Heat Stress scores
#Assign colors to each roof heat stress type
heat_stress_colors = {
    0.2 : 'limegreen',
    0.4 : 'yellowgreen',
    0.6 : 'gold',
    0.8 : 'orange',
    1 : 'red'}

#Plot Leeds map with colors based in the roof heat stress type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')
Matrix.plot(ax=ax, column='Roof_Score',
               color=Matrix['Roof_Score'].map(heat_stress_colors),
               legend=True)

ax.set_title('Roof Heat Resilience', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Roof Resilience Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""## Scoring **Property Type, Built Form and Total floor area** heat stress"""

Matrix['TOTAL_FLOOR_AREA'].describe()

Matrix['PROPERTY_TYPE'].value_counts()

Matrix = Matrix[Matrix["BUILT_FORM"] != "NO DATA!"]

Matrix['BUILT_FORM'].value_counts()

Matrix['FLAT_TOP_STOREY'].value_counts()

Matrix['TOTAL_FLOOR_AREA'].describe()

property_type_weights = {"House": 0.6,"Flat": 0.9, "Bungalow": 0.5,"Maisonette": 0.4,"Park home": 0.1,}

built_form_weights = {"Semi-detached": 0.6,"Mid-Terrace": 0.8, "Detached": 0.2,"End-Terrace": 0.3,"Enclosed Mid-Terrace": 0.7,"Enclosed End-Terrace": 0.4,}

flat_top_storey_weights = {"N": 0.1,"Y": 0.9,}

def assign_floor_area_weight(floor_area, percentile_25, percentile_50, percentile_75):
   if floor_area >= percentile_75:
    return 0.4
   elif floor_area >= percentile_50:
    return 0.6
   elif floor_area >= percentile_25:
    return 0.8
   else:
    return 1

def apply_individual_weights(certificates):
    required_cols = ["PROPERTY_TYPE", "BUILT_FORM", "FLAT_TOP_STOREY", "TOTAL_FLOOR_AREA"]
    percentile_25 = certificates["TOTAL_FLOOR_AREA"].quantile(0.25)
    percentile_50 = certificates["TOTAL_FLOOR_AREA"].quantile(0.50)
    percentile_75 = certificates["TOTAL_FLOOR_AREA"].quantile(0.75)
    certificates["PROPERTY_TYPE_WEIGHT"] = certificates["PROPERTY_TYPE"].map(property_type_weights)
    certificates["BUILT_FORM_WEIGHT"] = certificates["BUILT_FORM"].map(built_form_weights)
    certificates["FLAT_TOP_STOREY_WEIGHT"] = certificates["FLAT_TOP_STOREY"].map(flat_top_storey_weights)
    certificates["TOTAL_FLOOR_AREA_WEIGHT"] = certificates["TOTAL_FLOOR_AREA"].apply(
        lambda x: assign_floor_area_weight(x, percentile_25, percentile_50, percentile_75))

    return certificates

Matrix = apply_individual_weights(Matrix)

Matrix

"""Map the different scores"""

#Map Property Type Heat Susceptibility

from matplotlib.lines import Line2D  #for legend handle

#Assign colors to each Property heat stress type
heat_stress_colors = {
    0.1 : 'limegreen',
    0.4 : 'yellowgreen',
    0.5 : 'gold',
    0.6 : 'orange',
    0.9 : 'red'}

#Plot Leeds map with colors based in the Property heat stress type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')
Matrix.plot(ax=ax, column='PROPERTY_TYPE_WEIGHT',
               color=Matrix['PROPERTY_TYPE_WEIGHT'].map(heat_stress_colors),
               legend=True)

ax.set_title('Property Type Heat Resilience', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Property Type Heat Resilience Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

#Map Built Form Heat Susceptibility

from matplotlib.lines import Line2D  #for legend handle

#Assign colors to each Property heat stress type
heat_stress_colors = {
    0.2 : 'limegreen',
    0.3 : 'yellowgreen',
    0.4 : 'gold',
    0.6 : 'orange',
    0.7 : 'darkorange',
    0.8 : 'red'}

#Plot Leeds map with colors based in the Property heat stress type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')


#Remove NAs in column before plotting
Matrix_clean = Matrix.dropna(subset=['BUILT_FORM_WEIGHT'])
Matrix_clean.plot(ax=ax, column='BUILT_FORM_WEIGHT',
               color=Matrix_clean['BUILT_FORM_WEIGHT'].map(heat_stress_colors),
               legend=True)

ax.set_title('Building Type Heat Resilience', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Building Type Heat Resilience Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

#Map FLAT_TOP_STOREY Heat Susceptibility

from matplotlib.lines import Line2D  #for legend handle

#Assign colors to each FLAT_TOP_STOREY heat stress type
heat_stress_colors = {
    0.1 : 'limegreen',
    0.9 : 'red'}

#Plot Leeds map with colors based in the FLAT_TOP_STOREY heat stress type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')


#Remove NAs in column before plotting
Matrix_clean = Matrix.dropna(subset=['FLAT_TOP_STOREY_WEIGHT'])
Matrix_clean.plot(ax=ax, column='FLAT_TOP_STOREY_WEIGHT',
               color=Matrix_clean['FLAT_TOP_STOREY_WEIGHT'].map(heat_stress_colors),
               legend=True)

ax.set_title('Flat Top Storey Heat Resilience', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Flat Top Storey Heat Resilience Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

#Map TOTAL_FLOOR_AREA Heat Susceptibility

from matplotlib.lines import Line2D  #for legend handle

#Assign colors to each Property heat stress type
heat_stress_colors = {
    0.4 : 'yellowgreen',
    0.6 : 'gold',
    0.8 : 'orange',
    1 : 'red'}

#Plot Leeds map with colors based in the TOTAL_FLOOR_AREA heat stress type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')
Matrix.plot(ax=ax, column='TOTAL_FLOOR_AREA_WEIGHT',
               color=Matrix['TOTAL_FLOOR_AREA_WEIGHT'].map(heat_stress_colors),
               legend=True)

ax.set_title('Total Floor Area Heat Resilience', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Total Floor Area Heat Resilience Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""##Scoring **Walls** heat stress"""

Matrix['WALLS_DESCRIPTION'].nunique()

Matrix['WALLS_DESCRIPTION'].unique()

Matrix['WALLS_DESCRIPTION'].isna().sum()

#dropping null values from Walls_Description dataframe
Matrix = Matrix.dropna(subset=['WALLS_DESCRIPTION'])

Matrix.info()

Matrix['WALLS_DESCRIPTION'].value_counts().head()

printed_values = []

for value in Matrix['WALLS_DESCRIPTION']:
    if not any(char.isdigit() for char in value) and value not in printed_values:
        print(value)
        printed_values.append(value)

#This data desperately needs cleaning and sorting!
#will drop the welsh ones, also some are sandstone/limestone or granite/whinstone but for simplicity will group these materials

categories = ['Cavity', 'Brick', 'System built', 'Sandstone', 'Timber frame', 'Granite', 'Park home wall', 'Cob', 'Average']

unique_values = set()  #this is just to check all my categories are correct and the only values left should be Welsh/null, to drop
#set is so only unique values printed and so i can drop any matching values from dataframe

for value in Matrix['WALLS_DESCRIPTION']:
    if not any(cat.lower() in value.lower() for cat in categories):
        if value not in unique_values:
            print(value)
            unique_values.add(value)

Matrix = Matrix[~Matrix['WALLS_DESCRIPTION'].isin(unique_values)]

#average was just to make sure thermal transmitter values were not removed from the dataframe but it's not a building material so
#i am removing it from my list
categories.remove('Average')

fullcategories = []
for material in categories:
    fullcategories.append(material)
    fullcategories.append(f'{material}, no insulation')

print(fullcategories)

def wall_type(wall_mat):
    wall_mat = str(wall_mat).lower()
    if 'average' in wall_mat.lower():
        return wall_mat

    for material in categories:
        if material.lower() in wall_mat.lower():
            if 'no insulation' in wall_mat.lower():
                # Return the material type category with no insulation
                return f'{material.capitalize()}, no insulation'
            else:
                return material.capitalize()

Matrix['walltest'] = Matrix['WALLS_DESCRIPTION'].apply(wall_type)

Matrix['walltest'].nunique()

#before I convert these tidied material types into assumed u-values, I will extract the known u-values from the data.

materialsdict = {'Cavity': 0.25, 'Cavity, no insulation': 1.25, 'Brick': 0.3, 'Brick, no insulation': 1.75,
             'System built': 0.25, 'System built, no insulation': 2.0, 'Sandstone': 0.4,
             'Sandstone, no insulation': 2.0, 'Timber frame': 0.25, 'Timber frame, no insulation': 1.5,
             'Granite': 0.4, 'Granite, no insulation': 1.6, 'Park home wall': 0.3,
             'Park home wall, no insulation': 2.0, 'Cob': 1.0, 'Cob, no insulation': 0.2}

def wall_uvalue(wall_info):

    for material, uvalue in materialsdict.items():
        if material in wall_info:
            return uvalue

    return wall_info

import re

def extract_average(wall_desc):
    desc = str(wall_desc).lower()

    if 'average' in desc:
        cleaned_desc = re.sub(r'[^0-9\.]', '', str(wall_desc))
        match = re.search(r'(\d+\.\d+)', cleaned_desc)

        if match:
            return float(match.group(0))

    return wall_desc

Matrix['walltest2'] = Matrix['walltest'].apply(wall_uvalue)

Matrix['walltest2'] = Matrix['walltest2'].apply(extract_average)

Matrix[['WALLS_DESCRIPTION', 'walltest', 'walltest2']].head(15)

#Now all these functions are shown to have worked, I can change the final dataframe!

Matrix = Matrix.drop(columns=['walltest','walltest2'])

Matrix['wall_Uvalue'] = Matrix['WALLS_DESCRIPTION'].apply(wall_type)

Matrix['wall_Uvalue'] = Matrix['wall_Uvalue'].apply(wall_uvalue)

Matrix['wall_Uvalue'] = Matrix['wall_Uvalue'].apply(extract_average)

Matrix['wall_Uvalue'].isna().sum()

Matrix['wall_Uvalue'].describe()

Matrix.head()

bins = [0, 0.24, 0.26, 0.29, 0.45, float('inf')]
labels = ['Excellent', 'Good (Legal Limit)', 'Moderate', 'Poor', 'Bad']

Matrix['wall_rating'] = pd.cut(Matrix['wall_Uvalue'], bins=bins, labels=labels)

Matrix['wall_rating'] = Matrix['wall_rating'].astype(str)

Matrix['wall_rating'].value_counts()

wall_scores = {
    'Excellent': 0.2,
    'Good (Legal Limit)': 0.4,
    'Moderate': 0.6,
    'Poor': 0.8,
    'Bad': 1
}

#apply standardised scores
Matrix['Wall_Score'] = Matrix['wall_rating'].map(wall_scores)

Matrix.head()

from matplotlib.lines import Line2D  # for legend handle

#Assign colors to each heat stress type
heat_stress_colors = {
    'Excellent': 'limegreen',
    'Good (Legal Limit)': 'yellowgreen',
    'Moderate': 'gold',
    'Poor': 'orange',
    'Bad': 'red'}

#Plot Leeds map with colors based in the Walls heat stress type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')
Matrix_clean = Matrix[Matrix['wall_rating'] != 'nan'] #remove nan rows
Matrix_clean.plot(ax=ax, column='wall_rating',
               color=Matrix_clean['wall_rating'].map(heat_stress_colors),
               legend=True)
ax.set_title('Walls Heat Resilience', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Walls Heat Resilience Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""## Scoring **Property Age** heat stress"""

Matrix['CONSTRUCTION_AGE_BAND'].str.count("NO DATA!").sum()

Matrix['CONSTRUCTION_AGE_BAND'].unique()

Matrix['CONSTRUCTION_AGE_BAND'].isna().sum()

#drop NaN, NO DATA!, and invalid rows
Matrix = Matrix[~Matrix['CONSTRUCTION_AGE_BAND'].isin([None, 'NO DATA!', 'INVALID!'])]
Matrix = Matrix[~Matrix['CONSTRUCTION_AGE_BAND'].isna()]
Matrix['CONSTRUCTION_AGE_BAND'].unique()

#to categorise this data, I will sort it into 5 different categories. To do this, I will make some assumptions with the rows which only
#provide a year-range and not a specific year, that the property was built in the middle of the year range.

agebanddict = {'England and Wales: before 1900' : 1900, 'England and Wales: 1900-1929' : 1915,
       'England and Wales: 2007-2011' : 2009, 'England and Wales: 1983-1990' : 1987,
       'England and Wales: 1976-1982' : 1979, 'England and Wales: 1967-1975' : 1971,
       'England and Wales: 1996-2002' : 1999, 'England and Wales: 2007 onwards' : 2007,
       'England and Wales: 1950-1966' : 1958, 'England and Wales: 1930-1949' : 1938,
       'England and Wales: 1991-1995': 1993, 'England and Wales: 2003-2006' : 2004,
       'England and Wales: 2012 onwards' : 2012}

def get_cleaned_year(age_info):
    if isinstance(age_info, str):  #Only run if value is a string
        for unclean, year in agebanddict.items():
            if unclean in age_info:
                return year
    return age_info  #If not a string, return original value (float/year)

Matrix['construction_age'] = Matrix['CONSTRUCTION_AGE_BAND'].apply(get_cleaned_year)

Matrix.head()

Matrix.info()

Matrix['construction_age'] = Matrix['construction_age'].apply(lambda x: int(x))

bins_age = [0, 1965, 1984, 2003, 2010, 2025]
labels_age = ['Pre-1965', '1966-1984', '1985-2003', '2004-2010', '2011 onwards']

Matrix['age_rating'] = pd.cut(Matrix['construction_age'], bins=bins_age, labels=labels_age)

Matrix['age_rating'].value_counts()

#creating score for the index
age_score = {'Pre-1965' : 1, '1966-1984' : 0.8, '1985-2003' : 0.6, '2004-2010' : 0.4, '2011 onwards': 0.2}

Matrix['constructionagescore'] = Matrix['age_rating'].map(age_score)

Matrix['constructionagescore'] = Matrix['constructionagescore'].astype(float)

Matrix.head()

"""Map Age Score"""

from matplotlib.lines import Line2D  #for legend handle

#Plot Roof Heat Stress scores
#Assign colors to each roof heat stress type
heat_stress_colors = {
    0.2 : 'limegreen',
    0.4 : 'yellowgreen',
    0.6 : 'gold',
    0.8 : 'orange',
    1 : 'red'}

#Plot Leeds map with colors based in the roof heat stress type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')
Matrix.plot(ax=ax, column='constructionagescore',
               color=Matrix['constructionagescore'].map(heat_stress_colors),
               legend=True)

ax.set_title('Construction Age Heat Resilience', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Construction Age Heat Resilience Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""## Scoring **Floor** heat stress"""

Floor = Matrix[['FLOOR_DESCRIPTION', 'Index']]

NA = Floor.isnull().sum()
print(NA)

# Drop the NaN's in Floor Description
Floor = Floor.dropna(subset=['FLOOR_DESCRIPTION'])

# Remove redundant values
DROP = ['Conservatory','SAP05:Floor']
Floor=Floor[~Floor['FLOOR_DESCRIPTION'].isin(DROP)]

Floor.info()

# Extract the float value if 'FLOOR_DESCRIPTION' starts with "Average thermal transmittance"
Floor['Extracted_Float'] = Floor['FLOOR_DESCRIPTION'].str.extract(
    r'^Average thermal transmittance\s*=?\s*(\d+\.\d+)'
)

Floor.info()

# Clean Floor Description value names, add category and score
Floor_org = [
    ['FLOOR_DESCRIPTION', 'Floor_Cleaned', 'Floor_Category', 'Floor_Score'],
    ['(another dwelling below)', 'Premises below', 'Moderate',0.6],
    ['(other premises below)', 'Premises below', 'Moderate',0.6],
    ['(other premises below)|(eiddo arall islaw)', 'Premises below', 'Moderate',0.6],
    ['(Same dwelling below) insulated (assumed)', 'Premises below', 'Moderate',0.6],
    [', insulated (assumed)', 'Insulation (assumed)', 'Good', 0.4],
    [', no insulation (assumed)', 'No insulation (assumed)', 'Poor', 0.8],
    ['Crog, dim inswleiddio (rhagdybiaeth)', 'Suspended, no insulation (assumed)', 'Poor', 0.8],
    ['limited insulation (assumed)', 'Limited insulation (assumed)', 'Moderate',0.6],
    ['no insulation (assumed)', 'No insulation (assumed)', 'Poor', 0.8],
    ['Other premises below', 'Premises below', 'Moderate',0.6],
    ['Solet, dim inswleiddio (rhagdybiaeth)', 'Solid, no insulation (assumed)', 'Poor', 0.8],
    ['Solid,  insulated (assumed)', 'Solid, insulation (assumed)', 'Very Good', 0.2],
    ['Solid, insulated', 'Solid, insulation', 'Very Good', 0.2],
    ['Solid, insulated (assumed)', 'Solid, insulation (assumed)', 'Very Good', 0.2],
    ['Solid, limited insulation (assumed)', 'Solid, limited insulation (assumed)', 'Moderate',0.6],
    ['Solid, no insulation (assumed)', 'Solid, no insulation (assumed)', 'Poor', 0.8],
    ['Suspended', 'Suspended', 'Moderate',0.6],
    ['Suspended, insulated', 'Suspended, insulation', 'Very Good', 0.2],
    ['Suspended, insulated (assumed)', 'Suspended, insulation (assumed)', 'Very Good', 0.2],
    ['Suspended, limited insulation (assumed)', 'Suspended, limited insulation (assumed)', 'Moderate',0.6],
    ['Suspended, no insulation (assumed)', 'Suspended, no insulation (assumed)', 'Poor', 0.8],
    ['To external air, insulated', 'To external air, insulation', 'Good', 0.4],
    ['To external air, insulated (assumed)', 'To external air, insulation (assumed)', 'Good', 0.4],
    ['To external air, limited insulation (assumed)', 'To external air, limited insulation (assumed)', 'Moderate',0.6],
    ['To external air, no insulation (assumed)', 'To external air, no insulation (assumed)', 'Very Poor' , 1],
    ['To external air, uninsulated (assumed)', 'To external air, no insulation (assumed)', 'Very Poor' , 1],
    ['To unheated space,', 'To unheated space', 'Moderate',0.6],
    ['To unheated space, insulated (assumed)', 'To unheated space, insulation (assumed)', 'Good', 0.4],
    ['To unheated space, no insulation (assumed)', 'To unheated space, no insulation (assumed)', 'Very Poor' , 1],
    ['To unheated space, insulated', 'To unheated space, insulation', 'Good', 0.4],
    ['To unheated space, insulated (assumed)', 'To unheated space, insulation (assumed)', 'Good', 0.4],
    ['To unheated space,  insulated (assumed)', 'To unheated space, insulation (assumed)', 'Good', 0.4],
    ['To unheated space, limited insulation (assumed)', 'To unheated space, limited insulation (assumed)', 'Moderate',0.6],
    ['To unheated space, no insulation (assumed)', 'To unheated space, no insulation (assumed)', 'Very Poor' , 1],
    ['To unheated space,  no insulation (assumed)', 'To unheated space, no insulation (assumed)', 'Very Poor' , 1],
    ['To unheated space, uninsulated (assumed)', 'To unheated space, no insulation (assumed)', 'Very Poor' , 1]
]

# Create a new dataframe from the Floor_org list
columns = Floor_org[0]
data = Floor_org[1:]
Floor_df = pd.DataFrame(data, columns=columns)

# New subset removing all values that startswith Average thermal transmittance
Floor1 = Floor[~Floor['FLOOR_DESCRIPTION'].str.startswith('Average thermal transmittance')].copy()

# Drop column
Floor1 = Floor1.drop(columns=['Extracted_Float'])

# Convert Floor_org list to a dictionary
Floor_dict = {row[0]: (row[1], row[2], row[3]) for row in Floor_org[1:]}

# Map dictionary to fill in values in Floor1 df
Floor1[['Floor_Cleaned', 'Floor_Category', 'Floor_Score']] = Floor1['FLOOR_DESCRIPTION'].map(Floor_dict).apply(pd.Series)

Floor1.info()

Floor1.head()

NA_rows = Floor1[Floor1.isnull().any(axis=1)]
print(NA_rows)

# New subset for all values with Average thermal transmittance
Floor2 = Floor[['FLOOR_DESCRIPTION', 'Extracted_Float', 'Index']]

Floor2 = Floor2[Floor2['FLOOR_DESCRIPTION'].str.startswith('Average thermal transmittance', na=False)]

Floor2.info()

# Drop any NaN's
Floor2 = Floor2.dropna(subset=['Extracted_Float'])

# Change data type
Floor2['Extracted_Float'] = Floor2['Extracted_Float'].astype('float')

# Thresholds = 0.18 legal level, 0.25 considered improvement status, 0.7 final unacceptable level
bins = [ 0.00, 0.18, 0.25, 0.70, 0.71, 5.50]
labels = ['0.00-0.12', '0.13-0.18', '0.19-0.25', '0.26-0.70', '0.71-5.50']

# Create a new column using bins
Floor2['Floor_Thresholds'] = pd.cut(Floor2['Extracted_Float'], bins=bins, labels=labels)

Grouping = {
    'Very Good' : '0.00-0.12',
    'Good' : '0.13-0.18',
    'Moderate' : '0.19-0.25',
    'Poor' : '0.26-0.70',
    'Very Poor' : '0.71-5.50'
}

Scoring = {
    0.2 : 'Very Good',
    0.4 : 'Good',
    0.6 : 'Moderate',
    0.8 : 'Poor',
    1 : 'Very Poor'
}

# Fill 0.00 values with 0.00-0.12 in Threshold
Floor2.loc[Floor2['Extracted_Float'] == 0.00, 'Floor_Thresholds'] = '0.00-0.12'

# Fill Floor2['Category'] using the Grouping dictionary
Floor2['Floor_Category'] = Floor2['Floor_Thresholds'].map({v: k for k, v in Grouping.items()})

# Fill Floor2['Score'] using the Scoring dictionary
Floor2['Floor_Score'] = Floor2['Floor_Category'].map({v: k for k, v in Scoring.items()})

# New Cleaned name column, "Average Thermal Transmittance" + Floor2['Extracted_Float']
Floor2['Floor_Cleaned'] = "Average thermal transmittance " + Floor2['Extracted_Float'].astype(str)

Floor2.head()

NA_rows = Floor2[Floor2.isnull().any(axis=1)]
print(NA_rows)

Floor1.info()

Floor2.info()

# Change data type
Floor2['Extracted_Float'] = Floor2['Extracted_Float'].astype('object')
Floor2['Floor_Score'] = Floor2['Floor_Score'].astype('int64')
Floor2['Floor_Category'] = Floor2['Floor_Category'].astype('object')

# Join Floor1 and Floor 2 together
Floor1_concat = Floor1[['FLOOR_DESCRIPTION', 'Floor_Cleaned', 'Floor_Category', 'Floor_Score', 'Index']]
Floor2_concat = Floor2[['FLOOR_DESCRIPTION', 'Floor_Cleaned', 'Floor_Category', 'Floor_Score', 'Index']]

# Concatenate  dataframes
Floor3 = pd.concat([Floor1_concat, Floor2_concat], ignore_index=True)

# Drop redundant columns
Floor3 = Floor3.drop(columns=['Floor_Cleaned', 'Floor_Category'])

# Reorder columns
Floor3 = Floor3.loc[:,['Index', 'FLOOR_DESCRIPTION', 'Floor_Score']]
Floor3.info()

Floor3['Floor_Score'].unique()

Floor3.head()

Matrix = Matrix.merge(Floor3[['Index', 'Floor_Score']], on='Index', how='left')

Matrix.info()

"""**Add the floor scores to the overall Matrix**

Make map of Floor scores
"""

Matrix_clean = Matrix[Matrix['Floor_Score'] != 'nan'] #remove nan rows
Matrix_clean['Floor_Score'].unique()

na_count = Matrix['Floor_Score'].isna().sum()
print(na_count)

from matplotlib.lines import Line2D  #for legend handle

#Plot Roof Heat Stress scores
#Assign colors to each roof heat stress type
heat_stress_colors = {
    0 : 'lime',
    0.2 : 'limegreen',
    0.4 : 'yellowgreen',
    0.6 : 'gold',
    0.8 : 'orange',
    1 : 'red'}

#Plot Leeds map with colors based in the roof heat stress type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')

#Remove NAs in column before plotting
Matrix_clean = Matrix.dropna(subset=['Floor_Score'])
Matrix_clean.plot(ax=ax, column='Floor_Score',
               color=Matrix_clean['Floor_Score'].map(heat_stress_colors),
               legend=True)

ax.set_title('Floor Heat Resilience', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Heat Resilience Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""## Glazing type score and glazing proportion score"""

Matrix['GLAZED_TYPE'].value_counts()
glazing_types = Matrix['GLAZED_TYPE'].unique()
print(glazing_types)

glazing_dict = { 'single glazing': 0.8, 'double glazing installed before 2002': 0.6, 'double glazing, unknown install date' : 0.6, 'double glazing installed during or after 2002' : 0.4, 'double, known data': 0.4, 'secondary glazing' : 0.4, 'NO DATA!' : 0.4, 'INVALID!' : 0.4, 'triple glazing': 0.2 }
Matrix["glazing_score"] = Matrix["GLAZED_TYPE"].apply(lambda x: glazing_dict.get(x))
Matrix['glazing_score'].describe()

# Fill missing values with 50
Matrix['MULTI_GLAZE_PROPORTION'] = Matrix['MULTI_GLAZE_PROPORTION'].fillna(50)

# Convert glazing to proportion
Matrix['MULTI_GLAZE_PROPORTION2'] = Matrix['MULTI_GLAZE_PROPORTION'] / 100

# Define bins
bins_glaze = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]
labels_glaze = ['0.00-0.20', '0.21-0.40', '0.41-0.60', '0.61-0.80', '0.81-1.00']

# Categorise based on proportion thresholds
Matrix['glaze_prop_category'] = pd.cut(Matrix['MULTI_GLAZE_PROPORTION2'], bins=bins_glaze, labels=labels_glaze, include_lowest=True)

# Define the reverse scoring system
scoring_dict = {
    '0.81-1.00': 0.2,   # Very Good
    '0.61-0.80': 0.4,   # Good
    '0.41-0.60': 0.6,   # Moderate
    '0.21-0.40': 0.8,   # Poor
    '0.00-0.20': 1.0    # Very Poor
}

# Map scores to the categorized values
Matrix['MULTI_GLAZE_PROPORTION_Score'] = Matrix['glaze_prop_category'].map(scoring_dict)


# Display the results
print(Matrix[['MULTI_GLAZE_PROPORTION2', 'glaze_prop_category', 'MULTI_GLAZE_PROPORTION_Score']].head())

# Define bins based on the reversed scores
bins_glaze2 = [0, 0.2, 0.4, 0.6, 0.8, 1]
labels_glaze2 = ['Very Good', 'Good', 'Moderate', 'Poor', 'Very Poor']

# Assign categories based on MULTI_GLAZE_PROPORTION_Score
Matrix['glaze_prop_category2'] = pd.cut(Matrix['MULTI_GLAZE_PROPORTION_Score'], bins=bins_glaze2, labels=labels_glaze2, include_lowest=True)

print(Matrix[['MULTI_GLAZE_PROPORTION2', 'MULTI_GLAZE_PROPORTION_Score', 'glaze_prop_category', 'glaze_prop_category2']].head())

Matrix['MULTI_GLAZE_PROPORTION_Score'] = Matrix['MULTI_GLAZE_PROPORTION_Score'].astype(float)

#Map Glazing Type Heat Resilience

from matplotlib.lines import Line2D  #for legend handle

#Assign colors to each heat stress type
heat_stress_colors = {
    0.2 : 'limegreen',
    0.4 : 'yellowgreen',
    0.6 : 'gold',
    0.8 : 'orange'}

#Plot Leeds map with colors based in the Glazing heat resilience
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')


#Remove NAs in column before plotting
Matrix_clean = Matrix.dropna(subset=['glazing_score'])
Matrix_clean.plot(ax=ax, column='glazing_score',
               color=Matrix_clean['glazing_score'].map(heat_stress_colors),
               legend=True)

ax.set_title('Glazing Heat Resilience', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Glazing Heat Resilience Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

#Map MULTI_GLAZE_PROPORTION Heat Resilience

from matplotlib.lines import Line2D  #for legend handle

#Assign colors to each heat stress type
heat_stress_colors = {
    'Very Good' : 'limegreen',
    'Good' : 'yellowgreen',
    'Moderate' : 'gold',
    'Poor' : 'orange',
    'Very Poor' : 'red'}

#Plot Leeds map with colors based in the MULTI_GLAZE_PROPORTION heat resilience
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')


#Remove NAs in column before plotting
Matrix_clean = Matrix.dropna(subset=['glaze_prop_category2'])
Matrix_clean.plot(ax=ax, column='glaze_prop_category2',
               color=Matrix_clean['glaze_prop_category2'].map(heat_stress_colors),
               legend=True)

ax.set_title('Multi Glaze Proportion Heat Resilience', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Heat Resilience Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""#Calculating overall Heat Resilience Score"""

Matrix.info()

#Create Final Matrix
Matrix_Final = Matrix[['PROPERTY_TYPE_WEIGHT','BUILT_FORM_WEIGHT','TOTAL_FLOOR_AREA_WEIGHT',
                       'FLAT_TOP_STOREY_WEIGHT','MULTI_GLAZE_PROPORTION_Score','glazing_score',
                       'Wall_Score','Roof_Score','constructionagescore','Floor_Score', 'geometry',
                       'heat_stres', 'Index', 'LMK_KEY']]

Matrix_Final['MULTI_GLAZE_PROPORTION_Score'] = Matrix_Final['MULTI_GLAZE_PROPORTION_Score'].astype(float)

Matrix_Final.info()

#Specify columns to fill NAs with means
columns_to_fill = ['PROPERTY_TYPE_WEIGHT','BUILT_FORM_WEIGHT','TOTAL_FLOOR_AREA_WEIGHT',
                       'FLAT_TOP_STOREY_WEIGHT','MULTI_GLAZE_PROPORTION_Score','glazing_score',
                       'Wall_Score','Roof_Score','constructionagescore','Floor_Score']

#Apply fillna with mean only to the specified columns
Matrix_Final[columns_to_fill] = Matrix_Final[columns_to_fill].apply(lambda x: x.fillna(x.mean()), axis=0)

#check there are no more NAs in dataset
na_count = Matrix_Final.isna().sum()
print(na_count)
#Some poinst don't have geometries and cannot be mapped so will drop them

Matrix_Final = Matrix_Final.dropna(subset=['geometry'])
na_count = Matrix_Final.isna().sum()
print(na_count)

#Define weights of each property feature in the overall score
#For now they are all equal to 1 (needs to be changed)
weights = {
  'PROPERTY_TYPE_WEIGHT': 0.25 ,
  'BUILT_FORM_WEIGHT': 0.04,
  'TOTAL_FLOOR_AREA_WEIGHT': 0.25,
  'FLAT_TOP_STOREY_WEIGHT': 0.15,
  'MULTI_GLAZE_PROPORTION_Score': 0.04,
  'glazing_score': 0.04,
  'Wall_Score': 0.1 ,
  'Roof_Score': 0.05,
  'construction_age': 0.04,
  'Floor_Score': 0.04
}


#Create function to apply weight based on property characteritsics weights
def overall_score(row):
    score = 0
    for col, value in row.items():
        if col in weights:
            score += value * weights[col]

    return score

#Create column with overall heat susceptibility score by running function
Matrix_Final['Overall_Heat_Score'] = Matrix_Final.apply(overall_score, axis=1)

#Check
Matrix_Final.head()

"""Map the properties based on their overall heat resilience score. This will allow to compare side by side the initial Heat Stress map (taking into account only environmental factors) and our property heat susceptibility score."""

bins = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]
labels = ['Very Good', 'Good', 'Moderate', 'Poor', 'Very Poor']

Matrix_Final['Heat_Resilience_Category'] = pd.cut(Matrix_Final['Overall_Heat_Score'], bins=bins, labels=labels, include_lowest=True)

Matrix_Final['Heat_Resilience_Category'].value_counts()

Matrix_Final.head()

from matplotlib.lines import Line2D  # for legend handle

#Assign colors to each heat resilience type
heat_stress_colors = {
    'Very Good': 'limegreen',
    'Good': 'yellowgreen',
    'Moderate': 'gold',
    'Poor': 'orange',
    'Very Poor': 'red'}

#Plot Leeds map with colors based in the heat resilience type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')
Matrix_Final.plot(ax=ax, column='Heat_Resilience_Category',
               color=Matrix_Final['Heat_Resilience_Category'].map(heat_stress_colors),
               legend=True)
ax.set_title('Property Heat Resilience', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Heat Resilience Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

#custom_colors= ['limegreen','yellowgreen','gold','orange','red']
#sns.palplot(sns.color_palette(custom_colors))

"""Map the Environmental Heat Stress of Properties (to compare with map of heat resilience)"""

from matplotlib.lines import Line2D  # for legend handle

#Assign colors to each heat stress type
heat_stress_colors = {
    'Very Low': 'limegreen',
    'Low': 'yellowgreen',
    'Medium': 'gold',
    'High': 'orange',
    'Very High': 'red'}

#Plot Leeds map with colors based in the heat stress type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')
Matrix_Final.plot(ax=ax, column='heat_stres',
               color=Matrix_Final['heat_stres'].map(heat_stress_colors),
               legend=True)
ax.set_title('Leeds Heat Stress', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Heat Stress Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

Matrix_Final['Overall_Heat_Score'].describe()

Low_Resilience = Matrix_Final[['Heat_Resilience_Category', 'Index', 'geometry']]
DROP = ['Very Poor','Poor', 'Moderate']
Low_Resilience= Low_Resilience[~Low_Resilience['Heat_Resilience_Category'].isin(DROP)]
Low_Resilience.info()

from matplotlib.lines import Line2D  # for legend handle

#Assign colors to each heat stress type
heat_stress_colors = {
    'Very Low': 'limegreen',
    'Low': 'yellowgreen',
    'Medium': 'gold',
    'High': 'orange',
    'Very High': 'red'}

#Plot Leeds map with colors based in the heat stress type
fig, ax = plt.subplots(figsize=(10, 10))
LeedsOA.plot(ax = ax, color = 'lightgray')
Matrix_Final.plot(ax=ax, column='heat_stres',
               color=Matrix_Final['heat_stres'].map(heat_stress_colors),
               legend=True)
Low_Resilience.plot(ax=ax, column='Heat_Resilience_Category',
               color='Black',
               legend=True)
ax.set_title('Leeds Heat Stress', fontsize=16)
ax.set_axis_off()

#Add a legend
handles = [Line2D([0], [0], marker='o', color='w', markerfacecolor=v, label=k, markersize=8) for k, v in heat_stress_colors.items()]
ax.legend(title='Heat Stress Score', handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

import pandas as pd

# Save as CSV
Matrix_Final.to_csv("Matrix_Final4.csv", index=False)

import geopandas as gpd
import shutil

# Save Matrix_Final as an ESRI Shapefile
Matrix_Final.to_file("Matrix_Final4", driver="ESRI Shapefile")

# Compress all shapefile components into a ZIP file
shutil.make_archive("Matrix_Final4", "zip", "Matrix_Final4")

"""#Additional Considerations

#EPC Recommendations
"""

EPCrecom.info()

EPCrecom['INDICATIVE_COST'].isna().sum()

EPCrecom = EPCrecom.dropna(subset=['INDICATIVE_COST'])

EPCrecom['INDICATIVE_COST'] = EPCrecom['INDICATIVE_COST'].astype(str).str.replace(r'[^\d-]', '', regex=True)

EPCrecom[['LOWER_COST', 'UPPER_COST']] = EPCrecom['INDICATIVE_COST'].astype(str).str.split('-', n=1, expand=True)
EPCrecom[['LOWER_COST', 'UPPER_COST']] = EPCrecom[['LOWER_COST', 'UPPER_COST']].apply(lambda x: x.str.strip().replace('', np.nan).astype(float))

EPCrecom['INDICATIVE_COST'] = EPCrecom[['LOWER_COST', 'UPPER_COST']].mean(axis=1)

EPCrecom.head()

heat_stress_improvements = {'Cavity wall insulation', 'Draught proofing', 'Flat roof or sloping ceiling insulation', 'Floor insulation',
                            'Floor insulation (solid floor)', 'Floor insulation (suspended floor)',
                            'Internal or external wall insulation', 'Party wall insulation',
                            'Replace single glazed windows with low-E double glazed windows', 'Replacement glazing units', 'Room-in-roof insulation',
                            'Secondary glazing to single glazed windows'}

EPCrecom = EPCrecom[EPCrecom['IMPROVEMENT_SUMMARY_TEXT'].isin(heat_stress_improvements)]

EPCrecom.head()

EPCrecom['IMPROVEMENT_SUMMARY_TEXT'].nunique()

improvement_mean_cost = EPCrecom.groupby('IMPROVEMENT_SUMMARY_TEXT')['INDICATIVE_COST'].mean()

print(improvement_mean_cost)

"""# Improved matrix"""

import ipywidgets as widgets
from IPython.display import display

# Weightings for each variable
weights = {
    "Property Type": 0.25,
    "Building Form": 0.04,
    "Top Storey": 0.15,
    "Construction Age": 0.04,
    "Total Floor Area":  0.25,
    "Flooring": 0.04,
    "Proportion of Double Glazed": 0.04,
    "Glazing Type": 0.04,
    "Walls": 0.1,
    "Roof": 0.05
}
# Property type scoring
property_type_scores = {
    "House": 0.6,
    "Flat": 0.9,
    "Bungalow": 0.5,
    "Maisonette": 0.4,
    "Park home": 0.1
}

# Building form scoring
building_form_scores = {
    "Semi-detached": 0.6,
    "Mid-Terrace": 0.8,
    "Detached": 0.2,
    "End-Terrace": 0.3,
    "Enclosed Mid-Terrace": 0.7,
    "Enclosed End-Terrace": 0.4
}

# Total Floor Area scoring
floor_area_scores = {
    "Above 92m2": 0.4,
    "73-92m2 ": 0.6,
    "58-73m2": 0.8,
    "Below 28m2": 1
}

# Top Storey scoring
top_storey_scores = {
    "No": 0.1,
    "Yes": 0.9
}

# Construction age scoring
construction_age_scores = {
    "2011 onwards": 0.2,
    "2004-2010": 0.4,
    "1985-2003": 0.6,
    "1966-1964": 0.8,
    "Pre-1965": 1
}


# Category scoring
category_scores = {
    "Very Good": 0.2,
    "Good": 0.4,
    "Moderate": 0.6,
    "Poor": 0.8,
    "Very Poor": 1
}

# Dropdown widgets for each variable
property_type_dropdown = widgets.Dropdown(
    options=property_type_scores.keys(),
    value='House',
    description='Property Type:',
    disabled=False,
)

building_form_dropdown = widgets.Dropdown(
    options=building_form_scores.keys(),
    value='Semi-detached',
    description='Building Form:',
    disabled=False,
)

floor_area_dropdown = widgets.Dropdown(
    options=floor_area_scores.keys(),
    value='58-73m2',
    description='Total Floor Area:',
    disabled=False,
)

top_storey_dropdown= widgets.Dropdown(
    options=top_storey_scores.keys(),
    value='Yes',
    description='Top Storey:',
    disabled=False,
)

construction_age_dropdown= widgets.Dropdown(
    options=construction_age_scores.keys(),
    value='Pre-1965',
    description='Construction Age:',
    disabled=False,
)



flooring_dropdown = widgets.Dropdown(
    options=category_scores.keys(),
    value='Moderate',
    description='Flooring:',
    disabled=False,
)

proportion_dropdown = widgets.Dropdown(
    options=category_scores.keys(),
    value='Moderate',
    description='Proportion of Double Glazed:',
    disabled=False,
)

glaze_type_dropdown = widgets.Dropdown(
    options=category_scores.keys(),
    value='Moderate',
    description='Glazing Type:',
    disabled=False,
)

walls_dropdown = widgets.Dropdown(
    options=category_scores.keys(),
    value='Moderate',
    description='Walls:',
    disabled=False,
)

roof_dropdown = widgets.Dropdown(
    options=category_scores.keys(),
    value='Moderate',
    description='Roof:',
    disabled=False,
)

# Output label
result_label = widgets.Label(value="Final Heat Stress Score: ")

# Function to calculate final score and assign a category
def calculate_score(property, building, area, storey, age, flooring, proportion, glaze_type, walls, roof):
    total_score = (
        property_type_scores[property]* weights["Property Type"] +
        building_form_scores[building]* weights["Building Form"] +
        floor_area_scores[area]* weights["Top Storey"] +
        top_storey_scores[storey]* weights["Construction Age"] +
        construction_age_scores[age]* weights["Total Floor Area"] +
        category_scores[flooring] * weights["Flooring"] +
        category_scores[proportion] * weights["Proportion of Double Glazed"] +
        category_scores[glaze_type] * weights["Glazing Type"] +
        category_scores[walls] * weights["Walls"] +
        category_scores[roof] * weights["Roof"]
    )

    # Assign category from thresholds
    if total_score <= 0.2:
        category = "Very Good"
    elif total_score <= 0.4:
        category = "Good"
    elif total_score <= 0.6:
        category = "Moderate"
    elif total_score <= 0.8:
        category = "Poor"
    else:
        category = "Very Poor"

    result_label.value = f"Final Heat Resilience Score: {total_score:.2f}, Category: {category}"
    return result_label  # Ensures the output updates in the interactive widget

# Create interactive widget
interactive_widget = widgets.interactive_output(
    calculate_score,
    {
        'property': property_type_dropdown,
        'building':building_form_dropdown,
        'area': floor_area_dropdown,
        'storey': top_storey_dropdown,
        'age': construction_age_dropdown,
        'flooring': flooring_dropdown,
        'proportion': proportion_dropdown,
        'glaze_type': glaze_type_dropdown,
        'walls': walls_dropdown,
        'roof': roof_dropdown
    }
)

# Display dropdowns and result label
display(property_type_dropdown, building_form_dropdown, floor_area_dropdown, top_storey_dropdown, construction_age_dropdown, flooring_dropdown, proportion_dropdown, glaze_type_dropdown, walls_dropdown, roof_dropdown, interactive_widget, result_label)